% Provide functions working with lists.
(
	% Map a list with a callback.
	(def map #List,Callback :: (
		(var Result (list))
		(var MapInner (scope #Head,Tail :: (
			(set Result (++ Result (call Callback Head)))
			(if (!= 0 (length Tail)) (
				(call MapInner (head Tail) (tail Tail))
			))
		)))
		(if (!= 0 (length List)) (
			(call MapInner (head List) (tail List))
		))
		(Result)
	))

	% Foldl
	(def foldl #List,Initial,Callback :: (
		(var FoldlInner (scope #Head,Tail,Val0 :: (
			(var Val1 (call Callback Head Val0))
			(if (!= 0 (length Tail)) (
				(call FoldlInner (head Tail) (tail Tail) Val1)
			) (else (
				(Val1)
			)))
		)))
		(if (!= 0 (length List)) (
			(call FoldlInner (head List) (tail List) Initial)
		) (else (
			(Initial)
		)))
	))

	% Each. Similar to map but always returns nil.
	(def each #List,Callback :: (
		(var EachInner (scope #Head,Tail :: (
			(call Callback Head)
			(if (!= 0 (length Tail)) (
				(call EachInner (head Tail) (tail Tail))
			))
		)))
		(if (!= 0 (length List)) (
			(call EachInner (head List) (tail List))
		))
		(atom nil)
	))

	(export-global map/2 foldl/3 each/2)

	(if (== true (get-def 'DEBUG')) (
		(var SampleList (list 1 2 4 8 16 32))
		(print "Map test: " (map SampleList #N :: ((* N 2))))
		(print "Foldl test: " (foldl SampleList 0 #N,A :: ((+ N A))))
		(print "Empty map test: " (map (list) #N :: ((* N 2))))
		(print "Empty foldl test:" (foldl (list) 0 #N,A :: ((+ N A))))
		(each SampleList #N :: (
			(print "N:" N)
		))
	))

)
